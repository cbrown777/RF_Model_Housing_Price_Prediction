rm(list=ls())
#Import Data and Load Packages
pacman::p_load(dplyr, tidyr, magrittr, mlr, missForest)
pacman::p_load(stringr)
setwd("~/QC_Math_390.4_Spring_2019/labs")
getwd()

q_housing <- read.csv("housing_data_2016_2017.csv", header=TRUE, stringsAsFactors = FALSE) #Read the file in
View(q_housing) #View the file to check out relevant columns
which(names(q_housing) == "approx_year_built")
q_housing = q_housing[ , -seq(1, 28)] #Drop the first 28 irrelevant columns
dim(q_housing)
str(q_housing)
summary(q_housing)

lapply(q_housing, class) #See class type for all columns

q_housing %<>%
  select(-c(date_of_sale, url, model_type, common_charges, num_half_bathrooms, listing_price_to_nearest_1000)) %>%
  #Move sale_price last
  select(-sale_price, everything()) %>%
  mutate(community_district_num = factor(community_district_num)) %>% #Nominalize School District Number
  mutate(sale_price =  as.numeric(gsub('[$,]', '', q_housing$sale_price))) %>% #convert sale price to numeric and drop '$'
  #Convert maintenance_cost to numeric and drop '$'
  mutate(maintenance_cost =  as.numeric(gsub('[$,]', '', q_housing$maintenance_cost))) %>%
  #convert total_taxes to numeric and drop '$'
  mutate(total_taxes =  as.numeric(gsub('[$,]', '', q_housing$total_taxes))) %>%
  #convert parking_charges to numeric and drop '$'
  mutate(parking_charges =  as.numeric(gsub('[$,]', '', q_housing$parking_charges))) %>%
  #Fix spelling error in 'pct_tax_deductibl'
  rename(pct_tax_deductible = pct_tax_deductibl)




#Data Cleaning

#Converting duplicate values to y or n
unique(q_housing$cats_allowed)
unique(q_housing$dogs_allowed)
q_housing %<>%
  mutate(cats_allowed = as.factor(cats_allowed)) %>%
  mutate(dogs_allowed = as.factor(dogs_allowed))
q_housing %<>%
  mutate(cats_allowed = sub("yes", "y", cats_allowed)) %>%
  mutate(cats_allowed = sub("no", "n", cats_allowed)) %>%
  mutate(dogs_allowed = sub("yes", "y", dogs_allowed)) %>%
  mutate(dogs_allowed = sub("no", "n", dogs_allowed)) %>%
  mutate(dogs_allowed = sub("yes89", "y", dogs_allowed)) %>%
  mutate(dogs_allowed = sub("y89", "y", dogs_allowed))
unique(q_housing$cats_allowed)
unique(q_housing$dogs_allowed)  

class(q_housing$dogs_allowed)
isTRUE(all.equal(q_housing$cats_allowed, q_housing$dogs_allowed)) #There are buildings that only allow one animal

#Condense cats_allowed and dogs_allowed into one feature, animal_allowed.There isn't a significant difference in
#predictive power between dog or cat being allowed. 
q1 = as.data.frame(cbind(q_housing$dogs_allowed, q_housing$cats_allowed))
q1$animal_allowed <- apply(q1, 1, FUN = function(x) if(x[1] == 'y' | x[2] == 'y') 'y' else 'n')
q_housing = cbind(q_housing, q1$animal_allowed)
colnames(q_housing)[colnames(q_housing)=="q1$animal_allowed"] <- "animal_allowed"
rm(q1)

q_housing %<>%
  select(-c(cats_allowed, dogs_allowed)) %>%
  select(approx_year_built, animal_allowed, everything())




#Clean up fuel_type column
q_housing %<>%
  mutate(fuel_type = sub("Other", "other", fuel_type))
unique(q_housing$fuel_type)




#Clean up garage_exists column
q_housing %<>%
  mutate(garage_exists = sub("Underground", "y", garage_exists)) %>%
  mutate(garage_exists = sub("Yes", "y", garage_exists)) %>%
  mutate(garage_exists = sub("yes", "y", garage_exists)) %>%
  mutate(garage_exists = sub("UG", "y", garage_exists)) %>%
  mutate(garage_exists = sub("1", "y", garage_exists)) %>%
  mutate(garage_exists = sub("eys", "y", garage_exists))
#NA likely means there is none
q_housing$garage_exists[is.na(q_housing$garage_exists)] <- 'n'
unique(q_housing$garage_exists)

q_housing %<>% 
  select(approx_year_built, garage_exists, parking_charges, everything())

#Adds feature if there is no garage, and no parking charges listed.
#If a parking charge is listed but no garage is, it likely means there is a monthly fee for street parking. 
q2 = as.data.frame(cbind(q_housing$garage_exists, q_housing$parking_charges))
q2$no_garage_no_parking_charges <- apply(q2, 1, FUN = function(x) if(x[1] == 'n' & is.na(x[2])) 1 else 0)
q_housing = cbind(q_housing, q2$no_garage_no_parking_charges)
colnames(q_housing)[colnames(q_housing)=="q2$no_garage_no_parking_charges"] <- "no_garage_no_parking_charges"
rm(q2)
q_housing %<>% 
  select(approx_year_built, garage_exists, parking_charges, no_garage_no_parking_charges, everything())




#Clean up kitchen_type column
q_housing %<>%
  mutate(kitchen_type = sub("eat in", "eatin", kitchen_type)) %>%
  mutate(kitchen_type = sub("Eat In", "eatin", kitchen_type)) %>%
  mutate(kitchen_type = sub("Eat in", "eatin", kitchen_type)) %>%
  mutate(kitchen_type = sub("efficiency kitchene", "efficiency", kitchen_type)) %>%
  mutate(kitchen_type = sub("efficiency kitchen", "efficiency", kitchen_type)) %>%
  mutate(kitchen_type = sub("efficiemcy", "efficiency", kitchen_type)) %>%
  mutate(kitchen_type = sub("efficiency ktchen", "efficiency", kitchen_type)) %>%
  mutate(kitchen_type = sub("Combo", "combo", kitchen_type))
unique(q_housing$kitchen_type)




#Even though NA probably means there are 0 bedrooms, I didn't want to make that assumption
unique(q_housing$num_bedrooms)
#Even though NA probably means there is 1 floor, I didn't want to make that assumption
unique(q_housing$num_floors_in_building)




summary(q_housing$total_taxes)
hist(q_housing$total_taxes, breaks = 50)

#If total_taxes is less than 300, multiply by 12. It's very unlikely that total taxes
#for a condo or coop are less than 300 per year. This is likely due to inputting the data
#as monthly total taxes, instead of annually. Of course, this is a big assumption, and may lead
#to inaccurate predictions. 
q_housing %<>% 
  mutate(total_taxes = ifelse(total_taxes < 300, total_taxes * 12, total_taxes))



